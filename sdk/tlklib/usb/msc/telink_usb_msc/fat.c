/********************************************************************************************************
 * @file     fat.c
 *
 * @brief    This is the source file for BTBLE SDK
 *
 * @author	 BTBLE GROUP
 * @date         2,2022
 *
 * @par     Copyright (c) 2021, Telink Semiconductor (Shanghai) Co., Ltd. ("TELINK")
 *
 *          Licensed under the Apache License, Version 2.0 (the "License");
 *          you may not use this file except in compliance with the License.
 *          You may obtain a copy of the License at
 *
 *              http://www.apache.org/licenses/LICENSE-2.0
 *
 *          Unless required by applicable law or agreed to in writing, software
 *          distributed under the License is distributed on an "AS IS" BASIS,
 *          WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *          See the License for the specific language governing permissions and
 *          limitations under the License.
 *******************************************************************************************************/

#include "tlkapi/tlkapi_stdio.h"
#include "tlkdev/tlkdev_stdio.h"
#include "fat.h"

//dbr





const unsigned char dbr[512]=
{
#if (TLK_DEV_XT2602E_ENABLE)
 0xeb, 0x3e, 0x90,          //Jump instruction, cannot be changed to 0, otherwise it prompts that it is not formatted
 'M','S','D','O','S','5','.','0', //File system and version information "MSDOS5.0"
 0x00, 0x02,                //Number of bytes per sector, 512 bytes (11~12)
 0x40,                      //Number of sectors per cluster, 64 sectors (13)
 0x01, 0x00,                //Number of reserved sectors, 1 (14~15)
 0x02,                      //The number of FAT copies of this partition, which is 2 (16)
 0x00, 0x04,                //Number of root directory entries, 1024 entries (17~18)
 0x00, 0x00,                //The number of small sectors, here, is 0, which means to read the value from the large sector field (19~20)
 0xF8,                      //Media descriptor, 0xF8 means hard disk (21)
 0x40, 0x00,                //Number of sectors per FAT, 64 (22~23)
 0x40, 0x00,                //The number of sectors per track, 64 (exactly one sector) (24~25)
 0x00, 0x1e,                //The number of heads is 256M/32K-0x200 (16M) (reserve 512 32k sectors for program writing) (26~27)
 0x00, 0x00, 0x00, 0x00,    //Number of hidden sectors There is no hidden sector here, it is 0 (28~31)
 0x00, 0x80, 0x07, 0x00,    //Number of large sectors, the total number of sectors, 256k is 0x200 (32~35)
 0x80,                      //Disk drive parameters, 80 means hard disk (34)
 0x00,                      //Reserved (35)
 0x29,                      //Extended boot tag, 0x29 means the next three fields are available (36)
 0x88, 0x09, 0x71, 0x20,          //Label serial number (37~40)
#else
 0xeb, 0x3e, 0x90,          //Jump instruction, cannot be changed to 0, otherwise it prompts that it is not formatted
 'M','S','D','O','S','5','.','0', //File system and version information "MSDOS5.0"
 0x00, 0x02,                //Number of bytes per sector, 512 bytes (11~12)
 0x8,                      //Number of sectors per cluster, 8 sectors (13)
 0x01, 0x00,                //Number of reserved sectors, 1 (14~15)
 0x02,                      //The number of FAT copies of this partition, which is 2 (16)
 0x80, 0x00,                //The number of FAT copies of this partition, which is 2 (16)
 0x00, 0x02,                //The number of small sectors, here, 0x200 * 512 = 128k (19~20)
 0xF8,                      //Media descriptor, 0xF8 means hard disk (21)
 0x08, 0x00,                //Number of sectors per FAT, 8 (22~23)
 0x8, 0x00,                //Number of sectors per track, 8 (24~25)
 0x10, 0x00,                //The number of heads is 64 (26~27)
 0x00, 0x00, 0x00, 0x00,    //Number of hidden sectors There is no hidden sector here, it is 0 (28~31)
 0x00, 0x00, 0x00, 0x00,    //Number of large sectors, the total number of sectors(32~35)
 0x80,                      //Disk drive parameters, 80 means hard disk (34)
 0x00,                      //Reserved (35)
 0x29,                      //Extended boot tag, 0x29 means the next three fields are available (36)
 0x88, 0x09, 0x71, 0x20,          //Label serial number (37~40)
#endif
 //Disk label volume:Telink-demo
 'T','e', 'l', 'i', 'n', 'k', '-', 'd',
 'e', 'm', 'o',

 //File system type information, the string "FAT16"
 'F', 'A', 'T', '1', '6', 0x20,0x20, 0x20,

 //The following is the boot code
 0xf1, 0x7d,
 0xfa, 0x33, 0xc9, 0x8e,  0xd1, 0xbc, 0xfc, 0x7b,  0x16, 0x07, 0xbd, 0x78,  0x00, 0xc5, 0x76, 0x00,
 0x1e, 0x56, 0x16, 0x55,  0xbf, 0x22, 0x05, 0x89,  0x7e, 0x00, 0x89, 0x4e,  0x02, 0xb1, 0x0b, 0xfc,
 0xf3, 0xa4, 0x06, 0x1f,  0xbd, 0x00, 0x7c, 0xc6,  0x45, 0xfe, 0x0f, 0x8b,  0x46, 0x18, 0x88, 0x45,
 0xf9, 0xfb, 0x38, 0x66,  0x24, 0x7c, 0x04, 0xcd,  0x13, 0x72, 0x3c, 0x8a,  0x46, 0x10, 0x98, 0xf7,
 0x66, 0x16, 0x03, 0x46,  0x1c, 0x13, 0x56, 0x1e,  0x03, 0x46, 0x0e, 0x13,  0xd1, 0x50, 0x52, 0x89,
 0x46, 0xfc, 0x89, 0x56,  0xfe, 0xb8, 0x20, 0x00,  0x8b, 0x76, 0x11, 0xf7,  0xe6, 0x8b, 0x5e, 0x0b,
 0x03, 0xc3, 0x48, 0xf7,  0xf3, 0x01, 0x46, 0xfc,  0x11, 0x4e, 0xfe, 0x5a,  0x58, 0xbb, 0x00, 0x07,
 0x8b, 0xfb, 0xb1, 0x01,  0xe8, 0x94, 0x00, 0x72,  0x47, 0x38, 0x2d, 0x74,  0x19, 0xb1, 0x0b, 0x56,
 0x8b, 0x76, 0x3e, 0xf3,  0xa6, 0x5e, 0x74, 0x4a,  0x4e, 0x74, 0x0b, 0x03,  0xf9, 0x83, 0xc7, 0x15,
 0x3b, 0xfb, 0x72, 0xe5,  0xeb, 0xd7, 0x2b, 0xc9,  0xb8, 0xd8, 0x7d, 0x87,  0x46, 0x3e, 0x3c, 0xd8,
 0x75, 0x99, 0xbe, 0x80,  0x7d, 0xac, 0x98, 0x03,  0xf0, 0xac, 0x84, 0xc0,  0x74, 0x17, 0x3c, 0xff,
 0x74, 0x09, 0xb4, 0x0e,  0xbb, 0x07, 0x00, 0xcd,  0x10, 0xeb, 0xee, 0xbe,  0x83, 0x7d, 0xeb, 0xe5,
 0xbe, 0x81, 0x7d, 0xeb,  0xe0, 0x33, 0xc0, 0xcd,  0x16, 0x5e, 0x1f, 0x8f,  0x04, 0x8f, 0x44, 0x02,
 0xcd, 0x19, 0xbe, 0x82,  0x7d, 0x8b, 0x7d, 0x0f,  0x83, 0xff, 0x02, 0x72,  0xc8, 0x8b, 0xc7, 0x48,
 0x48, 0x8a, 0x4e, 0x0d,  0xf7, 0xe1, 0x03, 0x46,  0xfc, 0x13, 0x56, 0xfe,  0xbb, 0x00, 0x07, 0x53,
 0xb1, 0x04, 0xe8, 0x16,  0x00, 0x5b, 0x72, 0xc8,  0x81, 0x3f, 0x4d, 0x5a,  0x75, 0xa7, 0x81, 0xbf,
 0x00, 0x02, 0x42, 0x4a,  0x75, 0x9f, 0xea, 0x00,  0x02, 0x70, 0x00, 0x50,  0x52, 0x51, 0x91, 0x92,
 0x33, 0xd2, 0xf7, 0x76,  0x18, 0x91, 0xf7, 0x76,  0x18, 0x42, 0x87, 0xca,  0xf7, 0x76, 0x1a, 0x8a,
 0xf2, 0x8a, 0x56, 0x24,  0x8a, 0xe8, 0xd0, 0xcc,  0xd0, 0xcc, 0x0a, 0xcc,  0xb8, 0x01, 0x02, 0xcd,
 0x13, 0x59, 0x5a, 0x58,  0x72, 0x09, 0x40, 0x75,  0x01, 0x42, 0x03, 0x5e,  0x0b, 0xe2, 0xcc, 0xc3,
 0x03, 0x18, 0x01, 0x27,  0x0d, 0x0a, 0x49, 0x6e,  0x76, 0x61, 0x6c, 0x69,  0x64, 0x20, 0x73, 0x79,
 0x73, 0x74, 0x65, 0x6d,  0x20, 0x64, 0x69, 0x73,  0x6b, 0xff, 0x0d, 0x0a,  0x44, 0x69, 0x73, 0x6b,
 0x20, 0x49, 0x2f, 0x4f,  0x20, 0x65, 0x72, 0x72,  0x6f, 0x72, 0xff, 0x0d,  0x0a, 0x52, 0x65, 0x70,
 0x6c, 0x61, 0x63, 0x65,  0x20, 0x74, 0x68, 0x65,  0x20, 0x64, 0x69, 0x73,  0x6b, 0x2c, 0x20, 0x61,
 0x6e, 0x64, 0x20, 0x74,  0x68, 0x65, 0x6e, 0x20,  0x70, 0x72, 0x65, 0x73,  0x73, 0x20, 0x61, 0x6e,
 0x79, 0x20, 0x6b, 0x65,  0x79, 0x0d, 0x0a, 0x00,  0x49, 0x4f, 0x20, 0x20,  0x20, 0x20, 0x20, 0x20,
 0x53, 0x59, 0x53, 0x4d,  0x53, 0x44, 0x4f, 0x53,  0x20, 0x20, 0x20, 0x53,  0x59, 0x53, 0x80, 0x01,
 0x00, 0x57, 0x49, 0x4e,  0x42, 0x4f, 0x4f, 0x54,  0x20, 0x53, 0x59, 0x53,  0x00, 0x00, 0x55, 0xaa,
};

//Simulated file allocation table
//Where item 0 is 0xfff8 and item 1 is 0xFFFF, indicating that it has been used.
//Item 2 is 0xFFFF, indicating the end of the file. The remaining items are 0, indicating that they are not used
const unsigned char fat[64]=
{
 0xF8, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
 0x00, 0x00 ,0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
 0x00, 0x00 ,0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
 0x00, 0x00 ,0x00, 0x00,  0x00, 0x00, 0x00, 0x00
};

//A 64 byte 0 is used to fill in 0.
const unsigned char zeros[64]=
{
 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
 0x00, 0x00 ,0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
 0x00, 0x00 ,0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
 0x00, 0x00 ,0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
 0x00, 0x00 ,0x00, 0x00,  0x00, 0x00, 0x00, 0x00
};

//Test file data
const unsigned char test_file_data[64]=
{
 "just for test, 2018-4-11\r\n"
};


/********** The time format (16bits) is:**************
Bits15 ~ 11 represents hours, which can be 0 ~ 23; 
bits10 ~ 5 represents minutes, which can be 0 ~ 59; 
bits4 ~ 0 represents seconds, which can be 0 ~ 29, and each unit is 2 seconds, which means that the actual second value is 2 times of the value.
*/

/********* The date format (16bits) is:*************
 Bits15 ~ 9 represents the year, which can be 0 ~ 127. It represents the difference from 1980,
 That is to say, the actual year is this value plus 1980, which can be expressed up to 2107;

 Bits8 ~ 5 represents the month, which can be 1 ~ 12;
 Bits4 ~ 0 represents the number and can be 1 ~ 31.
*/

//Find the high byte of 16 bit time format
#define TIME_HB(H,M,S) (unsigned char)(((((H)<<11))|((M)<<5)|(S))>>8)
//Find the low byte of 16 bit time format
#define TIME_LB(H,M,S) (unsigned char)((((H)<<11))|((M)<<5)|(S))

//Find the high byte of 16 bit date format
#define DATE_HB(Y,M,D) (unsigned char)(((((Y)-1980)<<9)|((M)<<5)|(D))>>8)
//Find the low byte of 16 bit date format
#define DATE_LB(Y,M,D) (unsigned char)((((Y)-1980)<<9)|((M)<<5)|(D))


//root directory
const unsigned char root_dir[64]=
{
 //Disk label volume:Telink-demo
 'T','e', 'l', 'i', 'n', 'k', '-', 'd', 'e', 'm', 'o',
 0x08,                  //File property, indicating the label volume of the disk
 0x00,                  //Reserved
 0x00,                  //Create time millisecond timestamp

 //File creation time, 15:27:35
 TIME_LB(15,27,35), TIME_HB(15,27,35),

 //File creation date, August 19, 2008
 DATE_LB(2008,8,19), DATE_HB(2008,8,19),

 //Last visit date, August 20, 2008
 DATE_LB(2008,8,20), DATE_HB(2008,8,20),

 0x00, 0x00,            //High byte of starting cluster number, FAT12 / 16 must be 0

 //Last modified time, 15:36:47
 TIME_LB(15,36,47), TIME_HB(15,36,47),

 //Last revision date, August 19, 2008
 DATE_LB(2008,8,19), DATE_HB(2008,8,19),

 0x00, 0x00,            //Start cluster low word
 0x00, 0x00, 0x00, 0x00,   //file length

//Test files in root directory
 //File name "test. TXT"
 'T',  'E',   'S',  'T', ' ', ' ', ' ', ' ',  'T', 'X', 'T',
 0x00,                  //File properties, representing read-write files
 0x00,                  //Reserved
 0x00,                  //Create time millisecond timestamp
 //File creation time, 15:48:26
 TIME_LB(15,48,26), TIME_HB(15,48,26),

 //File creation date, August 19, 2008
 DATE_LB(2008,8,19), DATE_HB(2008,8,19),

 //Last visit date
 DATE_LB(2008,8,20), DATE_HB(2008,8,20),

 0x00, 0x00,            //High byte of starting cluster number, FAT12 / 16 must be 0

 //Last modified time, 15:50:33
 TIME_LB(15,50,33), TIME_HB(15,50,33),

 //Last revision date, August 19, 2008
 DATE_LB(2008,8,19), DATE_HB(2008,8,19),

 0x02, 0x00,            //Start cluster low word, cluster 2.

 //file length
 (sizeof(test_file_data)-1),((sizeof(test_file_data)-1)>>8), 0x00, 0x00,
};


